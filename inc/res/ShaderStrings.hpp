/**
 * @file ShaderStrings.hpp
 * @brief Auto-generated shader strings - DO NOT EDIT.
 */

#pragma once

#include <string>
#include <unordered_map>

namespace ShaderStrings {

// Source: pathTracer.comp
inline constexpr const char* PATHTRACER_COMP =
    "/**\n"
    " * @file pathTracer.comp\n"
    " * @brief Compute shader for path tracing rendering.\n"
    " */\n"
    "\n"
    "#version 450\n"
    "\n"
    "#ifndef VULKAN\n"
    "#extension GL_ARB_bindless_texture : require\n"
    "#else\n"
    "#extension GL_EXT_nonuniform_qualifier : require\n"
    "#endif\n"
    "\n"
    "layout(local_size_x = 32, local_size_y = 32) in;\n"
    "\n"
    "/**\n"
    " * @brief Storage buffer for accumulating radiance values for each pixel and wavelength.\n"
    " */\n"
    "layout(binding = 0) buffer Radiances {\n"
    "    float radiances[]; // Array to store the accumulated radiance for each pixel and wavelength\n"
    "} b_outRadiances; // Output buffer for radiances\n"
    "\n"
    "/**\n"
    " * @brief Uniform struct representing the scene parameters.\n"
    " */\n"
    "layout(binding = 1) uniform Scene {\n"
    "    int resX; // Resolution in X\n"
    "    int resY; // Resolution in Y\n"
    "    int traceDepth; // Trace depth\n"
    "    int currentSample; // Current sample count\n"
    "} u_scene; // Scene parameters\n"
    "\n"
    "/**\n"
    " * @brief Uniform struct representing the camera parameters.\n"
    " */\n"
    "layout(binding = 2) uniform Camera {\n"
    "    vec4 pos; // Camera position\n"
    "    vec4 dir; // Camera direction\n"
    "    vec4 up; // Camera up vector\n"
    "\n"
    "    float focal; // Focal length\n"
    "    float fov; // Field of view\n"
    "    float focusDist; // Focus distance\n"
    "    float fStop; // F-stop value\n"
    "} u_camera; // Camera parameters\n"
    "\n"
    "#ifdef VULKAN\n"
    "layout(binding = 3) uniform sampler2D u_textures[]; // Array of textures\n"
    "#else\n"
    "layout(binding = 3) buffer Textures {\n"
    "    sampler2D u_textures[]; // Array of textures\n"
    "};\n"
    "#endif\n"
    "\n"
    "/**\n"
    " * @brief Sample a texture at given UV coordinates.\n"
    " * @param index The index of the texture.\n"
    " * @param uv The UV coordinates.\n"
    " * @return The sampled color.\n"
    " */\n"
    "vec4 sampleTexture(uint index, vec2 uv) {\n"
    "#ifdef VULKAN\n"
    "    return texture(u_textures[nonuniformEXT(index)], uv);\n"
    "#else\n"
    "    return texture(sampler2D(u_textures[index]), uv);\n"
    "#endif\n"
    "}\n"
    "\n"
    "/**\n"
    " * @brief Struct representing a vertex in the mesh.\n"
    " */\n"
    "struct Vertex {\n"
    "    vec4 pos; // Position\n"
    "    vec4 normal; // Normal\n"
    "    vec4 tangent; // Tangent\n"
    "    vec2 texCoord; // Texture Coordinate\n"
    "    vec2 padding; // Padding for alignment\n"
    "};\n"
    "/**\n"
    " * @brief Storage buffer containing the vertices of the mesh.\n"
    " */\n"
    "layout(binding = 4) readonly buffer Vertices {\n"
    "    Vertex vertices[]; // Array of vertices\n"
    "} b_vertices; // Vertex buffer\n"
    "\n"
    "/**\n"
    " * @brief Struct representing a triangle in the mesh.\n"
    " */\n"
    "struct Triangle {\n"
    "    uint v0; // Index of vertex 0\n"
    "    uint v1; // Index of vertex 1\n"
    "    uint v2; // Index of vertex 2\n"
    "    uint idxMaterial; // Index of the material\n"
    "};\n"
    "/**\n"
    " * @brief Storage buffer containing the triangles of the mesh.\n"
    " */\n"
    "layout(binding = 5) readonly buffer Triangles {\n"
    "    Triangle triangles[]; // Array of triangles\n"
    "} b_triangles; // Triangle buffer\n"
    "\n"
    "/**\n"
    " * @brief Struct representing a material for a mesh.\n"
    " */\n"
    "struct Material {\n"
    "    int type; // Material type\n"
    "    float roughness; // Roughness\n"
    "    float temperature; // Temperature\n"
    "    float ior; // Index of Refraction\n"
    "\n"
    "    uint flags; // Material flags\n"
    "    uint idxNormalTex; // Index of normal texture\n"
    "    uint idxRoughnessTex; // Index of roughness texture\n"
    "    uint idxTemperatureTex; // Index of temperature texture\n"
    "\n"
    "    uint idxSpMaterial; // Index of associated spectral material\n"
    "    uint padding[3]; // Padding for alignment\n"
    "};\n"
    "\n"
    "const int MATERIAL_TYPE_DIFFUSE = 0; // Diffuse material\n"
    "const int MATERIAL_TYPE_SPECULAR = 1; // Specular material\n"
    "const int MATERIAL_TYPE_GLOSSY = 2; // Glossy material\n"
    "const int MATERIAL_TYPE_TRANSLUCENT = 3; // Translucent material\n"
    "\n"
    "const uint MATERIAL_NORMAL_MAP = 1 << 0; // Has normal texture\n"
    "const uint MATERIAL_ROUGHNESS_MAP = 1 << 1; // Has roughness texture\n"
    "const uint MATERIAL_TEMPERATURE_MAP = 1 << 2; // Has temperature texture\n"
    "\n"
    "/**\n"
    " * @brief Storage buffer containing the materials of the mesh.\n"
    " */\n"
    "layout(binding = 6) readonly buffer Materials {\n"
    "    Material materials[]; // Array of materials\n"
    "} b_materials; // Material buffer\n"
    "\n"
    "/**\n"
    " * @brief Struct representing a BVH node.\n"
    " */\n"
    "struct BvhNode {\n"
    "    uint idx; // Index of this node\n"
    "    uint rChildOffset; // Offset to the right child node\n"
    "    uint idxTriangle; // Index of the triangle (if leaf node)\n"
    "    uint leafFlag; // Flag indicating if this is a leaf node\n"
    "\n"
    "    vec4 aabbMin; // Minimum AABB coordinates\n"
    "    vec4 aabbMax; // Maximum AABB coordinates\n"
    "};\n"
    "/**\n"
    " * @brief Storage buffer containing the BVH nodes.\n"
    " */\n"
    "layout(binding = 7) readonly buffer BVH {\n"
    "    BvhNode bvhNodes[]; // Array of BVH nodes\n"
    "} b_BVH; // BVH buffer\n"
    "\n"
    "const float EPS = 0.00001; // Small epsilon value\n"
    "const float INFINITY = 1e20; // Large value representing infinity\n"
    "const float PI = 3.14159265359; // Value of pi\n"
    "\n"
    "uint g_rngState = 0; // Global RNG state\n"
    "/**\n"
    " * @brief Initialize the RNG state based on pixel coordinates and current sample.\n"
    " * @param pixel The pixel coordinates.\n"
    " * @param currentSample The current sample index.\n"
    " */\n"
    "void initRngState(ivec2 pixel, int currentSample) {\n"
    "    g_rngState = uint(pixel.x * 1973u + pixel.y * 9277u + currentSample * 26699u) | 1u;\n"
    "}\n"
    "/**\n"
    " * @brief Generate a random float in the range [0, 1).\n"
    " * @return A random float.\n"
    " */\n"
    "float rand() {\n"
    "    g_rngState ^= g_rngState << 13;\n"
    "    g_rngState ^= g_rngState >> 17;\n"
    "    g_rngState ^= g_rngState << 5;\n"
    "    return float(g_rngState) * (1.0 / 4294967296.0);\n"
    "}\n"
    "\n"
    "/**\n"
    " * @brief Build an orthonormal basis (u, v) given a normal vector (axis).\n"
    " * @param axis The normal vector.\n"
    " * @param[out] u Output vector for the first tangent.\n"
    " * @param[out] v Output vector for the second tangent.\n"
    " */\n"
    "void buildOrthonormalBasis(vec3 axis, out vec3 u, out vec3 v) {\n"
    "    vec3 tmp = abs(axis.x) < 1.0 - EPS ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);\n"
    "    u = normalize(cross(tmp, axis));\n"
    "    v = cross(axis, u);\n"
    "}\n"
    "/**\n"
    " * @brief Sample a direction on the hemisphere around the normal vector using cosine-weighted\n"
    "          sampling.\n"
    " * @param n The normal vector at the point of interaction.\n"
    " * @param[out] pdf Output variable to store the PDF value for the sampled direction.\n"
    " * @return A sampled direction vector on the hemisphere.\n"
    " */\n"
    "vec3 cosineSampleHemisphere(vec3 n, out float pdf) {\n"
    "    float r = sqrt(rand());\n"
    "    float phi = 2.0 * PI * rand();\n"
    "\n"
    "    float x = r * cos(phi);\n"
    "    float y = r * sin(phi);\n"
    "    float z = sqrt(max(0.0, 1.0 - r * r));\n"
    "\n"
    "    vec3 u, v;\n"
    "    buildOrthonormalBasis(n, u, v);\n"
    "    vec3 dir = normalize(x * u + y * v + z * n);\n"
    "    pdf = z / PI;\n"
    "\n"
    "    return dir;\n"
    "}\n"
    "/**\n"
    " * @brief Compute the GGX normal distribution function (NDF) for given NdotH and alpha.\n"
    " * @param NdotH The dot product of the normal and half-vector.\n"
    " * @param alpha The roughness parameter squared.\n"
    " * @return The GGX NDF value.\n"
    " */\n"
    "float D_GGX(float NdotH, float alpha) {\n"
    "    float a2 = alpha * alpha;\n"
    "    float denom = NdotH * NdotH * (a2 - 1.0) + 1.0;\n"
    "    return a2 / (PI * denom * denom);\n"
    "}\n"
    "/**\n"
    " * @brief Compute the Schlick-GGX geometric shadowing function for given NdotV and alpha.\n"
    " * @param NdotV The dot product of the normal and view vector.\n"
    " * @param alpha The roughness parameter squared.\n"
    " * @return The Schlick-GGX geometric shadowing value.\n"
    " */\n"
    "float G_SchlickGGX(float NdotV, float alpha) {\n"
    "    float k = (alpha + 1.0);\n"
    "    k = (k * k) / 8.0;\n"
    "    return NdotV / (NdotV * (1.0 - k) + k);\n"
    "}\n"
    "/**\n"
    " * @brief Sample a half-vector H based on the GGX distribution given the normal and roughness.\n"
    " * @param N The normal vector at the point of interaction.\n"
    " * @param alpha The roughness parameter squared.\n"
    " * @param[out] pdf Output variable to store the PDF value for the sampled half-vector.\n"
    " * @return A sampled half-vector H based on the GGX distribution.\n"
    " */\n"
    "vec3 sampleGGX(vec3 N, float alpha, out float pdf) {\n"
    "    float u1 = rand();\n"
    "    float u2 = rand();\n"
    "\n"
    "    float a2 = alpha * alpha;\n"
    "\n"
    "    float phi = 2.0 * PI * u1;\n"
    "    float cosTheta = sqrt((1.0 - u2) / (1.0 + (a2 - 1.0) * u2));\n"
    "    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));\n"
    "\n"
    "    vec3 u, v;\n"
    "    buildOrthonormalBasis(N, u, v);\n"
    "    vec3 H = normalize(\n"
    "        sinTheta * cos(phi) * u +\n"
    "        sinTheta * sin(phi) * v +\n"
    "        cosTheta * N\n"
    "    );\n"
    "    pdf = D_GGX(cosTheta, alpha) * cosTheta;\n"
    "\n"
    "    return H;\n"
    "}\n"
    "/**\n"
    " * @brief Sample a direction for glass materials based on the incident direction, normal,\n"
    "          and index of refraction.\n"
    " * @param wi The incident direction.\n"
    " * @param n The surface normal at the point of interaction.\n"
    " * @param[inout] inside A flag indicating if the ray is currently inside the material.\n"
    " * @param ior The index of refraction of the material.\n"
    " * @return A sampled direction vector for reflection or refraction.\n"
    " */\n"
    "vec3 sampleGlass(vec3 wi, vec3 n, inout bool inside, float ior) {\n"
    "    float nc = 1.0;\n"
    "    float ng = ior;\n"
    "\n"
    "    float eta = inside ? ng / nc : nc / ng;\n"
    "\n"
    "    float cosi = abs(dot(wi, n));\n"
    "    float r0 = pow((nc - ng) / (nc + ng), 2.0);\n"
    "    float k = 1.0 - eta * eta * (1.0 - cosi * cosi);\n"
    "\n"
    "    vec3 r = reflect(wi, n);\n"
    "\n"
    "    if (k < 0.0)\n"
    "        return r; // Total internal reflection\n"
    "\n"
    "    float re = r0 + (1.0 - r0) * pow(1.0 - cosi, 2.0);\n"
    "\n"
    "    if (rand() < re)\n"
    "        return r;\n"
    "    else {\n"
    "        inside = !inside;\n"
    "        return normalize(\n"
    "            eta * wi - (eta * dot(n, wi) + sqrt(k)) * n\n"
    "        );\n"
    "    }\n"
    "}\n"
    "/**\n"
    " * @brief Sample a point uniformly on a unit disk.\n"
    " * @return A 2D vector representing the sampled point on the disk.\n"
    " */\n"
    "vec2 sampleDisk() {\n"
    "    float r = sqrt(rand());\n"
    "    float theta = 2.0 * PI * rand();\n"
    "    return vec2(cos(theta), sin(theta)) * r;\n"
    "}\n"
    "\n"
    "/**\n"
    " * @brief Struct representing a ray in 3D space.\n"
    " */\n"
    "struct Ray {\n"
    "    vec3 origin; // Origin of the ray\n"
    "    vec3 direction; // Direction of the ray\n"
    "};\n"
    "\n"
    "/**\n"
    " * @brief Struct representing the result of a ray intersection.\n"
    " */\n"
    "struct HitRecord {\n"
    "    bool hit; // Flag indicating if an intersection occurred\n"
    "    float t; // Distance to intersection\n"
    "    vec3 normal; // Surface normal at intersection\n"
    "    vec3 tangent; // Interpolated tangent at intersection\n"
    "    vec2 texCoord; // Texture coordinates at intersection\n"
    "    uint idxMaterial; // Index of the material at intersection\n"
    "};\n"
    "/**\n"
    " * @brief Function to test ray-triangle intersection.\n"
    " * @param ray The ray to test.\n"
    " * @param tri The triangle to test against.\n"
    " * @return The result of the intersection test.\n"
    " */\n"
    "HitRecord hitTriangle(Ray ray, Triangle tri) {\n"
    "    HitRecord result;\n"
    "    result.t = INFINITY;\n"
    "    result.hit = false;\n"
    "\n"
    "    Vertex v0 = b_vertices.vertices[tri.v0];\n"
    "    Vertex v1 = b_vertices.vertices[tri.v1];\n"
    "    Vertex v2 = b_vertices.vertices[tri.v2];\n"
    "\n"
    "    vec3 p0 = v0.pos.xyz;\n"
    "    vec3 p1 = v1.pos.xyz;\n"
    "    vec3 p2 = v2.pos.xyz;\n"
    "\n"
    "    vec3 e1 = p1 - p0;\n"
    "    vec3 e2 = p2 - p0;\n"
    "\n"
    "    vec3 p = cross(ray.direction, e2);\n"
    "    float det = dot(e1, p);\n"
    "\n"
    "    if (abs(det) < EPS)\n"
    "        return result;\n"
    "\n"
    "    float invDet = 1.0 / det;\n"
    "    vec3 tvec = ray.origin - p0;\n"
    "\n"
    "    float u = dot(tvec, p) * invDet;\n"
    "    if (u < 0.0 || u > 1.0)\n"
    "        return result;\n"
    "\n"
    "    vec3 q = cross(tvec, e1);\n"
    "    float v = dot(ray.direction, q) * invDet;\n"
    "    if (v < 0.0 || (u + v) > 1.0)\n"
    "        return result;\n"
    "\n"
    "    float t = dot(e2, q) * invDet;\n"
    "    if (t < EPS)\n"
    "        return result;\n"
    "\n"
    "    /* ===== Hit confirmed ===== */\n"
    "    result.hit = true;\n"
    "    result.t = t;\n"
    "\n"
    "    float w = 1.0 - u - v;\n"
    "\n"
    "    vec3 n0 = v0.normal.xyz;\n"
    "    vec3 n1 = v1.normal.xyz;\n"
    "    vec3 n2 = v2.normal.xyz;\n"
    "    result.normal = normalize(n0 * w + n1 * u + n2 * v);\n"
    "    if (dot(result.normal, ray.direction) > 0.0f)\n"
    "        result.normal = -result.normal;\n"
    "\n"
    "    vec3 t0v = v0.tangent.xyz;\n"
    "    vec3 t1v = v1.tangent.xyz;\n"
    "    vec3 t2v = v2.tangent.xyz;\n"
    "    vec3 tanInterp = t0v * w + t1v * u + t2v * v;\n"
    "    result.tangent = normalize(tanInterp - result.normal * dot(result.normal, tanInterp));\n"
    "\n"
    "    vec2 uv0 = v0.texCoord;\n"
    "    vec2 uv1 = v1.texCoord;\n"
    "    vec2 uv2 = v2.texCoord;\n"
    "    result.texCoord = uv0 * w + uv1 * u + uv2 * v;\n"
    "\n"
    "    result.idxMaterial = tri.idxMaterial;\n"
    "\n"
    "    return result;\n"
    "}\n"
    "/**\n"
    " * @brief Function to test ray-AABB intersection.\n"
    " * @param ray The ray to test.\n"
    " * @param aabbMin The minimum coordinates of the AABB.\n"
    " * @param aabbMax The maximum coordinates of the AABB.\n"
    " * @return The distance to the intersection or INFINITY if no intersection occurs.\n"
    " */\n"
    "float hitAABB(Ray ray, vec3 aabbMin, vec3 aabbMax) {\n"
    "    vec3 invDir = 1.0 / ray.direction;\n"
    "\n"
    "    vec3 t0 = (aabbMin - ray.origin) * invDir;\n"
    "    vec3 t1 = (aabbMax - ray.origin) * invDir;\n"
    "\n"
    "    vec3 tmin = min(t0, t1);\n"
    "    vec3 tmax = max(t0, t1);\n"
    "\n"
    "    float tNear = max(max(tmin.x, tmin.y), tmin.z);\n"
    "    float tFar  = min(min(tmax.x, tmax.y), tmax.z);\n"
    "\n"
    "    if (tFar < max(tNear, 0.0))\n"
    "        return INFINITY;\n"
    "\n"
    "    return tNear;\n"
    "}\n"
    "/**\n"
    " * @brief Function to traverse the BVH and find the closest intersection.\n"
    " * @param ray The ray to trace.\n"
    " * @return The closest hit record.\n"
    " */\n"
    "HitRecord traverseBVH(Ray ray) {\n"
    "    HitRecord closest;\n"
    "    closest.t = INFINITY;\n"
    "    closest.hit = false;\n"
    "\n"
    "    const int MAX_STACK = 64;\n"
    "    int stack[MAX_STACK];\n"
    "    int stackPtr = 0;\n"
    "\n"
    "    stack[stackPtr++] = 0; // root\n"
    "\n"
    "    while (stackPtr > 0) {\n"
    "        int nodeIdx = stack[--stackPtr];\n"
    "        BvhNode node = b_BVH.bvhNodes[nodeIdx];\n"
    "\n"
    "        float nodeHit = hitAABB(ray, node.aabbMin.xyz, node.aabbMax.xyz);\n"
    "        if (nodeHit == INFINITY || nodeHit > closest.t)\n"
    "            continue;\n"
    "\n"
    "        if (node.leafFlag != 0) {\n"
    "            Triangle tri = b_triangles.triangles[node.idxTriangle];\n"
    "            HitRecord hit = hitTriangle(ray, tri);\n"
    "\n"
    "            if (hit.hit && hit.t < closest.t)\n"
    "                closest = hit;\n"
    "        } else {\n"
    "            int leftChild  = nodeIdx + 1;\n"
    "            int rightChild = int(nodeIdx + node.rChildOffset);\n"
    "\n"
    "            float tLeft = hitAABB(\n"
    "                ray,\n"
    "                b_BVH.bvhNodes[leftChild].aabbMin.xyz,\n"
    "                b_BVH.bvhNodes[leftChild].aabbMax.xyz\n"
    "            );\n"
    "\n"
    "            float tRight = INFINITY;\n"
    "            if (node.rChildOffset != 0) {\n"
    "                tRight = hitAABB(\n"
    "                    ray,\n"
    "                    b_BVH.bvhNodes[rightChild].aabbMin.xyz,\n"
    "                    b_BVH.bvhNodes[rightChild].aabbMax.xyz\n"
    "                );\n"
    "            }\n"
    "\n"
    "            if (tLeft < tRight) {\n"
    "                if (tRight < INFINITY)\n"
    "                    stack[stackPtr++] = rightChild;\n"
    "                if (tLeft < INFINITY)\n"
    "                    stack[stackPtr++] = leftChild;\n"
    "            } else {\n"
    "                if (tLeft < INFINITY)\n"
    "                    stack[stackPtr++] = leftChild;\n"
    "                if (tRight < INFINITY)\n"
    "                    stack[stackPtr++] = rightChild;\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "\n"
    "    return closest;\n"
    "}\n"
    "\n"
    "/**\n"
    " * @brief Uniform struct representing the spectral scene parameters.\n"
    " */\n"
    "layout(binding = 8) uniform SpectralScene {\n"
    "    int nWaves; // Number of wavelength samples\n"
    "    uint idxSkyMaterial; // Index of the sky material in the spectral materials buffer\n"
    "    float skyTemperature; // Temperature of the sky for blackbody radiation calculations\n"
    "} u_spScene; // Spectral scene parameters\n"
    "/**\n"
    " * @brief Storage buffer containing the wave numbers corresponding to each wavelength sample.\n"
    " */\n"
    "layout(binding = 9) readonly buffer Waves {\n"
    "    float waveNumbers[]; // Array of wave numbers corresponding to each wavelength sample\n"
    "} b_waves; // Wave number buffer\n"
    "/**\n"
    " * @brief Storage buffer containing the spectral emissivity values for each material and\n"
    " *        wavelength.\n"
    " */\n"
    "layout(binding = 10) readonly buffer SpMaterials {\n"
    "    float emissivities[]; // Spectral emissivity values for each material and wavelength\n"
    "} b_spMaterials; // Spectral material properties buffer\n"
    "\n"
    "/**\n"
    " * @brief Compute the blackbody radiation power for a given temperature and wave number.\n"
    " * @param temperature The temperature in Celsius.\n"
    " * @param waveNumber The wave number corresponding to the wavelength sample.\n"
    " * @return The blackbody radiation power for the given parameters.\n"
    " */\n"
    "float bbp(float temperature, float waveNumber) {\n"
    "    const float c = 299792458.0;\n"
    "    const float k = 1.0 * 138064852e-31;\n"
    "    const float h = 2.0 * PI * 105457180e-42;\n"
    "    float v = waveNumber;\n"
    "    float T = temperature + 273.15;\n"
    "    return 2e8 * (h * c * c * v * v * v) / (exp(100.0 * h * c * v / k / T) - 1.0);\n"
    "}\n"
    "\n"
    "/**\n"
    " * @brief Trace a ray through the scene and compute the radiance contribution for a specific\n"
    " *        wavelength sample.\n"
    " * @param ray The ray to trace.\n"
    " * @param idxWave The index of the wavelength sample to compute the radiance for.\n"
    " * @return The computed radiance contribution for the given ray and wavelength sample.\n"
    " */\n"
    "float trace(Ray ray, int idxWave) {\n"
    "    Ray newRay = ray;\n"
    "\n"
    "    float radiance = 0.0;\n"
    "    float throughput = 1.0;\n"
    "\n"
    "    int bounces = 0;\n"
    "    bool inside = false;\n"
    "\n"
    "    while (bounces < u_scene.traceDepth) {\n"
    "        HitRecord hit = traverseBVH(newRay);\n"
    "\n"
    "        // ===== MISS : use sky =====\n"
    "        if (!hit.hit) {\n"
    "            int idxSky = int(u_spScene.idxSkyMaterial) * u_spScene.nWaves + idxWave;\n"
    "            float skyEmiss = b_spMaterials.emissivities[idxSky];\n"
    "            float skyBB = bbp(u_spScene.skyTemperature, b_waves.waveNumbers[idxWave]);\n"
    "            float skyRadiance = skyEmiss * skyBB;\n"
    "            radiance += throughput * skyRadiance;\n"
    "            break;\n"
    "        }\n"
    "\n"
    "        // ===== HIT =====\n"
    "        vec3 p = newRay.origin + newRay.direction * hit.t;\n"
    "        vec3 n = normalize(hit.normal);\n"
    "        Material material = b_materials.materials[hit.idxMaterial];\n"
    "\n"
    "        // normal mapping\n"
    "        if ((material.flags & MATERIAL_NORMAL_MAP) != 0) {\n"
    "            vec3 t = hit.tangent;\n"
    "            vec3 b = normalize(cross(n, t));\n"
    "            mat3 TBN = mat3(t, b, n);\n"
    "            vec3 nTex =\n"
    "                sampleTexture(material.idxNormalTex, hit.texCoord).xyz * 2.0 - 1.0;\n"
    "            n = normalize(TBN * nTex);\n"
    "        }\n"
    "\n"
    "        p += n * EPS;\n"
    "\n"
    "        // ===== Emission term =====\n"
    "        int idxEmiss = int(material.idxSpMaterial) * u_spScene.nWaves + idxWave;\n"
    "        float spectralEmittance = b_spMaterials.emissivities[idxEmiss];\n"
    "\n"
    "        float temperature = material.temperature;\n"
    "        if ((material.flags & MATERIAL_TEMPERATURE_MAP) != 0)\n"
    "            temperature = sampleTexture(material.idxTemperatureTex, hit.texCoord).r;\n"
    "\n"
    "        float blackbodyRadiance = bbp(temperature, b_waves.waveNumbers[idxWave]);\n"
    "        float emittedRadiance = spectralEmittance * blackbodyRadiance;\n"
    "        radiance += throughput * emittedRadiance;\n"
    "\n"
    "        // ===== Sample next direction =====\n"
    "        vec3 wi = newRay.direction;\n"
    "        vec3 wo;\n"
    "\n"
    "        if (material.type == MATERIAL_TYPE_DIFFUSE) {\n"
    "            float pdf = 0.0;\n"
    "            vec3 wo = cosineSampleHemisphere(n, pdf);\n"
    "            float cosTheta = max(dot(wo, n), 0.0);\n"
    "            float brdf = 1.0 / PI;\n"
    "            throughput *= brdf * cosTheta / pdf;\n"
    "        }\n"
    "        else if (material.type == MATERIAL_TYPE_GLOSSY) {\n"
    "            float roughness = material.roughness;\n"
    "            if ((material.flags & MATERIAL_ROUGHNESS_MAP) != 0)\n"
    "                roughness = sampleTexture(material.idxRoughnessTex, hit.texCoord).r;\n"
    "            float alpha = roughness * roughness;\n"
    "\n"
    "            vec3 V = -wi;\n"
    "            float NdotV = max(dot(n, V), 0.0);\n"
    "            if (NdotV <= 0.0)\n"
    "                break;\n"
    "            float pdf_h = 0.0;\n"
    "            vec3 H = sampleGGX(n, alpha, pdf_h);\n"
    "            vec3 L = reflect(-V, H);\n"
    "            float NdotL = max(dot(n, L), 0.0);\n"
    "            float NdotH = max(dot(n, H), 0.0);\n"
    "            float VdotH = max(dot(V, H), 0.0);\n"
    "            if (NdotL <= 0.0)\n"
    "                break;\n"
    "\n"
    "            float D = D_GGX(NdotH, alpha);\n"
    "            float G = G_SchlickGGX(NdotV, alpha) * G_SchlickGGX(NdotL, alpha);\n"
    "\n"
    "            float F0 = (material.ior - 1.0) / (material.ior + 1.0);\n"
    "            F0 *= F0;\n"
    "            float F = F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n"
    "\n"
    "            float pdf = pdf_h / (4.0 * VdotH);\n"
    "            float brdf = (D * G * F) / (4.0 * NdotV * NdotL);\n"
    "            throughput *= brdf * NdotL / pdf;\n"
    "\n"
    "            wo = L;\n"
    "        }\n"
    "        else if (material.type == MATERIAL_TYPE_TRANSLUCENT) {\n"
    "            wo = sampleGlass(wi, n, inside, material.ior);\n"
    "            if (inside)\n"
    "                p -= n * EPS * 2.0;\n"
    "        }\n"
    "        else // specular\n"
    "            wo = reflect(wi, n);\n"
    "\n"
    "        newRay.origin = p;\n"
    "        newRay.direction = normalize(wo);\n"
    "\n"
    "        bounces++;\n"
    "        // Russian roulette\n"
    "        if (bounces > 3) {\n"
    "            float p = clamp(throughput, 0.05, 0.95);\n"
    "            if (rand() > p)\n"
    "                break;\n"
    "            throughput /= p;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    return radiance;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);\n"
    "\n"
    "    if (pixel.x >= u_scene.resX || pixel.y >= u_scene.resY)\n"
    "        return;\n"
    "\n"
    "    initRngState(pixel, u_scene.currentSample);\n"
    "\n"
    "    vec2 uv = (vec2(pixel) + 0.5) / vec2(u_scene.resX, u_scene.resY);\n"
    "    vec2 ndc = uv * 2.0 - 1.0;\n"
    "\n"
    "    vec3 forward = normalize(u_camera.dir.xyz);\n"
    "    vec3 right = normalize(cross(forward, u_camera.up.xyz));\n"
    "    vec3 up = cross(right, forward);\n"
    "\n"
    "    float halfHeight = tan(radians(u_camera.fov * 0.5)) * u_camera.focal;\n"
    "    float halfWidth  = halfHeight * float(u_scene.resX) / float(u_scene.resY);\n"
    "\n"
    "    vec3 imageCenter = u_camera.pos.xyz + forward * u_camera.focal;\n"
    "    vec3 imagePoint = imageCenter + ndc.x * halfWidth * right + ndc.y * halfHeight * up;\n"
    "\n"
    "    vec3 pinholeDir = normalize(imagePoint - u_camera.pos.xyz);\n"
    "    // Focus plane intersection\n"
    "    float tFocus = u_camera.focusDist / dot(pinholeDir, forward);\n"
    "    vec3 focusPoint = u_camera.pos.xyz + pinholeDir * tFocus;\n"
    "    // Aperture\n"
    "    float apertureRadius = 0.5 * (u_camera.focal / u_camera.fStop);\n"
    "    // Lens sampling\n"
    "    vec2 lensSample = sampleDisk() * apertureRadius;\n"
    "    vec3 lensOffset = right * lensSample.x + up * lensSample.y;\n"
    "\n"
    "    Ray ray;\n"
    "    ray.origin = u_camera.pos.xyz + lensOffset;\n"
    "    ray.direction = normalize(focusPoint - ray.origin);\n"
    "\n"
    "    // Hero wavelength sampling\n"
    "    int idxWave = int(rand() * float(u_spScene.nWaves));\n"
    "    float radiance = trace(ray, idxWave);\n"
    "\n"
    "    float pLambda = 1.0 / float(u_spScene.nWaves);\n"
    "    radiance /= pLambda;\n"
    "\n"
    "    int waveBlockSize = u_scene.resX * u_scene.resY;\n"
    "    int pixelIndex = pixel.y * u_scene.resX + pixel.x;\n"
    "\n"
    "    for (int i = 0; i < u_spScene.nWaves; ++i) {\n"
    "        int bufferIndex = i * waveBlockSize + pixelIndex;\n"
    "\n"
    "        float contribution = (i == idxWave) ? radiance : 0.0;\n"
    "        float oldValue = b_outRadiances.radiances[bufferIndex];\n"
    "        float newValue = oldValue * float(u_scene.currentSample - 1) + contribution;\n"
    "        newValue /= float(u_scene.currentSample);\n"
    "\n"
    "        b_outRadiances.radiances[bufferIndex] = newValue;\n"
    "    }\n"
    "}\n"
    "";

// Source: preview.frag
inline constexpr const char* PREVIEW_FRAG =
    "/**\n"
    " * @file preview.frag\n"
    " * @brief Fragment shader for the previewer.\n"
    " */\n"
    "\n"
    "#version 450\n"
    "\n"
    "layout(location = 0) in vec3 v_posW; // World space position\n"
    "layout(location = 1) in vec3 v_normalW; // World space normal\n"
    "layout(location = 2) in vec3 v_tangentW; // World space tangent\n"
    "layout(location = 3) in vec2 v_texCoord; // Texture coordinate\n"
    "\n"
    "/**\n"
    " * @brief Uniform struct for camera position.\n"
    " */\n"
    "#ifdef VULKAN\n"
    "layout(set = 2, binding = 1)\n"
    "#else\n"
    "layout(binding = 1)\n"
    "#endif\n"
    "uniform Camera {\n"
    "    vec3 posW; // Camera world position\n"
    "} u_camera; // Camera data\n"
    "\n"
    "/**\n"
    " * @brief Uniform struct for material properties.\n"
    " */\n"
    "layout(binding = 2) uniform Material {\n"
    "    vec4 diffuse; // Diffuse color (or highlight color)\n"
    "    float roughness; // Roughness\n"
    "    uint flags; // Material flags\n"
    "} u_material; // Material data\n"
    "const uint MATERIAL_NORMAL_MAP = 1 << 0; // Has normal texture\n"
    "const uint MATERIAL_ROUGHNESS_MAP = 1 << 1; // Has roughness texture\n"
    "const uint MATERIAL_INTENSITY_MAP = 1 << 2; // Has intensity texture (not used)\n"
    "const uint MATERIAL_HIGHLIGHT = 1 << 3; // Highlighted material\n"
    "\n"
    "layout(binding = 3) uniform sampler2D u_normalTex; // Normal texture\n"
    "layout(binding = 4) uniform sampler2D u_roughnessTex; // Roughness texture\n"
    "layout(binding = 5) uniform sampler2D u_intensityTex; // Intensity texture\n"
    "\n"
    "/**\n"
    " * @brief Uniform struct for object picking information.\n"
    " */\n"
    "layout(binding = 6) uniform PickInfo {\n"
    "    uint modelID; // Model ID\n"
    "    uint meshID; // Mesh ID\n"
    "} u_pickInfo; // Picking information\n"
    "\n"
    "layout(location = 0) out vec4 o_fragColor; // Final fragment color\n"
    "layout(location = 1) out vec4 o_pickColor; // Picking color for color pick buffer\n"
    "\n"
    "void main() {\n"
    "    // Light direction in world space (camera as light source)\n"
    "    vec3 l = normalize(u_camera.posW - v_posW);\n"
    "    // Normal in world space\n"
    "    vec3 n = normalize(v_normalW);\n"
    "    if (dot(n, l) < 0.0)\n"
    "        n = -n;\n"
    "    if ((u_material.flags & MATERIAL_NORMAL_MAP) != 0) {\n"
    "        vec3 bitangentW = normalize(cross(v_normalW, v_tangentW));\n"
    "        mat3 tbn = mat3(v_tangentW, bitangentW, v_normalW);\n"
    "        vec3 nt = normalize(texture(u_normalTex, v_texCoord).xyz * 2.0 - 1.0);\n"
    "        n = tbn * nt;\n"
    "    }\n"
    "\n"
    "    float roughness = u_material.roughness;\n"
    "    if ((u_material.flags & MATERIAL_ROUGHNESS_MAP) != 0)\n"
    "        roughness = texture(u_roughnessTex, v_texCoord).r;\n"
    "\n"
    "    vec3 diffuse = u_material.diffuse.rgb;\n"
    "    if ((u_material.flags & MATERIAL_INTENSITY_MAP) != 0)\n"
    "        diffuse = texture(u_intensityTex, v_texCoord).rgb;\n"
    "    diffuse *= max(dot(n, l), 0.0);\n"
    "\n"
    "    vec3 specular = vec3(1.0);\n"
    "    float specularFact = pow(max(dot(n, l), 0.0), 128.0 * (1.0 - roughness));\n"
    "    specularFact *= max(dot(n, l), 0.0);\n"
    "    specular *= specularFact;\n"
    "\n"
    "    vec3 shade = (diffuse + specular) * 0.5;\n"
    "    if ((u_material.flags & MATERIAL_HIGHLIGHT) != 0)\n"
    "        shade = diffuse;\n"
    "\n"
    "    o_fragColor = vec4(shade, 1.0);\n"
    "\n"
    "    o_pickColor = vec4(u_pickInfo.modelID, u_pickInfo.meshID, 1.0, 1.0);\n"
    "}\n"
    "";

// Source: preview.vert
inline constexpr const char* PREVIEW_VERT =
    "/**\n"
    " * @file preview.vert\n"
    " * @brief Vertex shader for the previewer.\n"
    " */\n"
    "\n"
    "#version 450\n"
    "\n"
    "layout(location = 0) in vec3 i_pos; // Vertex position\n"
    "layout(location = 1) in vec3 i_normal; // Vertex normal\n"
    "layout(location = 2) in vec3 i_tangent; // Vertex tangent\n"
    "layout(location = 3) in vec2 i_texCoord; // Vertex texture coordinate\n"
    "\n"
    "/**\n"
    " * @brief Uniform struct for model, view, and projection matrices.\n"
    " */\n"
    " #ifdef VULKAN\n"
    "layout(set = 1, binding = 0)\n"
    "#else\n"
    "layout(binding = 0)\n"
    "#endif\n"
    "uniform Xform {\n"
    "    mat4 proj; // Projection matrix\n"
    "    mat4 view; // View matrix\n"
    "    mat4 model; // Model matrix\n"
    "} u_xform; // Transformation matrices\n"
    "\n"
    "layout(location = 0) out vec3 v_posW; // World space position\n"
    "layout(location = 1) out vec3 v_normalW; // World space normal\n"
    "layout(location = 2) out vec3 v_tangentW; // World space tangent\n"
    "layout(location = 3) out vec2 v_texCoord; // Texture coordinate\n"
    "\n"
    "void main() {\n"
    "    v_posW = vec3(u_xform.model * vec4(i_pos, 1.0));\n"
    "    v_normalW = normalize(mat3(u_xform.model) * i_normal);\n"
    "    v_tangentW = normalize(mat3(u_xform.model) * i_tangent);\n"
    "    v_texCoord = i_texCoord;\n"
    "\n"
    "    gl_Position = u_xform.proj * u_xform.view * vec4(v_posW, 1.0);\n"
    "}\n"
    "";

// Source: quad.frag
inline constexpr const char* QUAD_FRAG =
    "/**\n"
    " * @file quad.frag\n"
    " * @brief Fragment shader for rendering a textured quad.\n"
    " */\n"
    "\n"
    "#version 450\n"
    "\n"
    "layout(location = 0) in vec2 v_texCoord; // Texture coordinate\n"
    "\n"
    "layout(binding = 0) buffer Radiances {\n"
    "    float radiances[];\n"
    "} b_radiances;\n"
    "\n"
    "/**\n"
    " * @brief Uniform buffer for shader parameters.\n"
    " */\n"
    "layout(binding = 1) uniform Params {\n"
    "    int channel; // Channel selection\n"
    "    int resX; // Horizontal resolution\n"
    "    int resY; // Vertical resolution\n"
    "} u_params; // Shader parameters\n"
    "\n"
    "layout(location = 0) out vec4 o_fragColor; // Final fragment color\n"
    "\n"
    "void main() {\n"
    "    int pixelX = int(v_texCoord.x * u_params.resX);\n"
    "    int pixelY = int(v_texCoord.y * u_params.resY);\n"
    "    pixelX = clamp(pixelX, 0, u_params.resX - 1);\n"
    "    pixelY = clamp(pixelY, 0, u_params.resY - 1);\n"
    "\n"
    "    int waveBlockSize = u_params.resX * u_params.resY;\n"
    "    int bufferIndex = u_params.channel * waveBlockSize + pixelY * u_params.resX + pixelX;\n"
    "    float radiance = b_radiances.radiances[bufferIndex];\n"
    "\n"
    "    o_fragColor = vec4(radiance, radiance, radiance, 1.0);\n"
    "}\n"
    "";

// Source: quad.vert
inline constexpr const char* QUAD_VERT =
    "/**\n"
    " * @file quad.vert\n"
    " * @brief Vertex shader for rendering a textured quad.\n"
    " */\n"
    "\n"
    "#version 450\n"
    "\n"
    "#ifdef VULKAN\n"
    "#define gl_VertexID gl_VertexIndex\n"
    "#endif\n"
    "\n"
    "layout(location = 0) out vec2 v_texCoord; // Output texture coordinates\n"
    "\n"
    "// Predefined vertex positions for a full-screen quad\n"
    "const vec4 g_vertices[4] = vec4[](\n"
    "    vec4(-1.0, -1.0, 0.0, 1.0),\n"
    "    vec4( 1.0, -1.0, 0.0, 1.0),\n"
    "    vec4(-1.0,  1.0, 0.0, 1.0),\n"
    "    vec4( 1.0,  1.0, 0.0, 1.0)\n"
    ");\n"
    "\n"
    "void main() {\n"
    "    gl_Position = g_vertices[gl_VertexID];\n"
    "    v_texCoord = (gl_Position.xy + vec2(1.0)) * 0.5;\n"
    "}\n"
    "";

/**
 * @brief Retrieve the shader string by name.
 * @param name The name of the shader file.
 * @return The shader source code as a string, or an empty string if not found.
 */
inline std::string get(const std::string& name) {
    static const auto map = std::unordered_map<std::string, std::string> {
        { "pathTracer.comp", PATHTRACER_COMP },
        { "preview.frag", PREVIEW_FRAG },
        { "preview.vert", PREVIEW_VERT },
        { "quad.frag", QUAD_FRAG },
        { "quad.vert", QUAD_VERT },
    };
    if (auto it = map.find(name); it != map.end())
        return it->second;
    return {};
}

} // namespace ShaderStrings
